当然，这篇文章的核心观点是：**许多被广泛推崇的 “Clean Code” (整洁代码) 编程原则，尤其是那些影响代码结构的核心规则，会对程序性能造成毁灭性的打击，其性能损失可能高达 10 到 15 倍以上。** 这种性能倒退相当于抹掉了过去十多年的硬件发展成果。

作者通过一个计算不同形状面积的经典例子，对比了三种实现方式的性能差异。

---

###  实验对比：计算图形面积 📐

实验设定是计算一系列不同形状（正方形、长方形、三角形、圆形）的总面积。

#### 1. “Clean Code” 方式 (多态)
这种方法严格遵守 “Clean Code” 原则：
* **“优先使用多态而不是 switch”**：创建一个 `shape_base` 基类和多个派生类（`square`, `rectangle` 等），每个派生类实现自己的 `Area()` 虚函数。
* **“函数应该短小” & “只做一件事”**：每个 `Area()` 函数都非常简单。
* **结果**：通过调用虚函数来计算面积。这是典型的面向对象设计。
* **性能**：处理每个形状平均耗时约 **35 个时钟周期**。这是性能基准。

#### 2. “传统” 方式 (Switch 语句)
这种方法违反了第一条规则，回归到更过程化的编程方式：
* **实现**：使用一个统一的结构体 `shape_union` 和一个 `enum` 来表示形状类型。编写一个 `GetAreaSwitch()` 函数，内部使用 `switch` 语句根据形状类型执行相应的面积计算。
* **优点**：
    * **数据局部性**：所有形状数据可以存放在一个连续的数组中，没有指针间接寻址的开销。
    * **编译器友好**：编译器能看到所有可能的代码路径，更容易进行内联和优化。
* **性能**：处理每个形状平均耗时约 **24 个时钟周期**，比 “Clean Code” 版本**快了 1.5 倍**。

#### 3. “数据驱动” 方式 (查表法)
这种方法进一步违反了 **“代码不应了解其处理对象的内部结构”** 这一规则：
* **实现**：作者观察到所有面积计算都有共同模式（例如 `系数 * 宽 * 高`）。于是，他创建了一个常量表，根据形状类型直接查找对应的计算系数。整个计算简化为一次查表和一次乘法。
* **优点**：代码不仅**更快**，而且**更简单**、行数更少。这种“以操作为中心”的组织方式，比“以类型为中心”（每个类一个文件）的组织方式更容易发现优化模式。
* **性能**：处理每个形状平均耗时仅约 **3.5 个时钟周期**，比 “Clean Code” 版本**快了整整 10 倍**！

---

### ## 增加复杂度后的影响 💥

作者随后将问题稍微复杂化：计算“角的数量加权后的面积”。

* 在 “Clean Code” 版本中，这意味着增加**另一个虚函数调用** (`CornerCount()`)，导致性能进一步下降。
* 在 “数据驱动” 版本中，**核心代码完全不变**，只需预先计算好新的系数并更新查找表即可。

**结果是，性能差距被进一步拉大**。数据驱动版本比 “Clean Code” 版本的性能优势扩大到了近 **15 倍**。作者指出，这证明了 “Clean Code” 的方法论在问题变复杂时，性能惩罚会越来越严重。

---

### ## 结论与建议 💡

作者总结，在五个影响代码结构的主要 “Clean Code” 规则中：

* **四个是极其有害的**：包括使用多态、信息隐藏、函数短小等，它们阻碍了编译器优化，并引入了不必要的开销。
* **一个是基本无害的**：“DRY - 不要重复自己 (Don't Repeat Yourself)” 通常是合理的建议。

作者认为，**“Clean Code” 是导致当今软件普遍缓慢和臃肿的重要原因之一**。为了追求一种被认为是“易于维护”的结构，开发者牺牲了巨大的性能，这完全是得不偿失的。编写易于维护和阅读的代码本身是正确的目标，但当前流行的这些 “Clean Code” 规则，显然是错误的方法。在采纳这些规则之前，开发者必须清楚地认识到其背后可能高达 15 倍甚至更多的性能代价。